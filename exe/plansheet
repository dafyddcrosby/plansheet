#!/usr/bin/env ruby
# frozen_string_literal: true

require "plansheet"
require "optparse"

parser = OptionParser.new
parser.on(
  "--sheet",
  "Generates MD/LaTeX project PDF"
)
parser.on(
  "--sort",
  "Sort project files"
)
parser.on(
  "--irb",
  "Open IRB console after loading projects"
)
parser.on(
  "--cli",
  "CLI dump of projects (WIP)"
)
parser.on(
  "--stats",
  "Various stats (WIP)"
)
parser.on(
  "--time-roi",
  "Show projects with a time return-on-investment"
)
parser.on(
  "--calendar",
  "List of projects ordered by due date"
)
parser.on(
  "--location_filter LOCATION",
  "location filter for CLI dump (WIP)"
)
options = {}
parser.parse!(into: options)

config = Plansheet.load_config
pool = Plansheet::Pool.new({ projects_dir: config["projects_dir"],
                             sort_order: config["sort_order"] })

if options[:sheet] || options.empty?
  require "plansheet/sheet"
  Dir.mkdir config["output_dir"] unless Dir.exist? config["output_dir"]
  Plansheet::Sheet.new("#{config["output_dir"]}/projects.md", pool.projects)
elsif options[:irb]
  binding.irb # rubocop:disable Lint/Debugger
elsif options[:stats]
  puts "# of projects: #{pool.projects.count}"
  puts "# of tasks: #{pool.projects.sum { |x| x&.tasks&.count || 0 }}"
  puts "# of locations: #{pool.projects.collect(&:location).flatten.delete_if(&:nil?).uniq.count}"
  puts "combined time estimate: #{pool.projects.sum { |x| x.time_estimate_minutes || 0 }} minutes"
elsif options[:sort]
  # Pool sorts projects, this now just matches old behaviour
  pool.write_projects
elsif options[:"time-roi"]
  project_arr = pool.projects.select {|x| x.time_roi_payoff != 0 && !x.dropped_or_done?}.sort
  project_arr.each do |proj|
    puts proj
    puts "time ROI payoff: #{proj.time_roi_payoff}"
    puts "\n"
  end
elsif options[:calendar]
  # TODO: add a project filter method
  project_arr = pool.projects
  project_arr.delete_if { |x| x.status == "dropped" || x.status == "done" }
  project_arr.delete_if { |x| x.due.nil? }
  project_arr.sort_by!(&:due)
  project_arr.each do |proj|
    puts proj
    puts "\n"
  end
elsif options[:cli]
  # TODO: add a project filter method
  project_arr = pool.projects
  project_arr.delete_if { |x| x.status == "dropped" || x.status == "done" }
  project_arr.select! { |x| x.location == options[:location_filter] } if options[:location_filter]
  project_arr.each do |proj|
    puts proj
    puts "\n"
  end
end
